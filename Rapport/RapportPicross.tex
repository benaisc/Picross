\documentclass{article}
\usepackage{hyperref}
\usepackage[table,xcdraw]{xcolor}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{lscape}
\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{verbatim}
\begin{document}
\title{Rapport de projet Picross}
\author{CONNES Victor \and PRYSIAZHNIUK Anastasiia \and BENAIS-HUGOT Charles \and RIVIERE Cecilie}
\maketitle
\tableofcontents 
\newpage
\section{Description du problème}

Le Picross est un casse-tête qui consiste à retrouver une figure depuis les indices. La figure à découvrir est une grille dans laquelle chaque case est de couleur noire ou blanche. Pour chacune des lignes et colonnes on dispose d'un indice qui est une séquence de nombres représentant les longueurs des blocs de cases noires contiguës de la ligne/colonne. Les blocs de cases noires sont séparés par au moins une case blanche.

\begin{table}[h]
\centering
\begin{tabular}{ccccccc}
\textbf{}  & \textbf{}                       & \textbf{3}                                                                    & \textbf{4}                                                                    & \textbf{4}                                                                    & \textbf{4}                                                                    & \textbf{3}                                                                    \\ \cline{3-7} 
\textbf{2} & \multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{000000} \textbf{}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\textbf{}}                                                & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        \\ \cline{3-7} 
\textbf{}  & \multicolumn{1}{c|}{\textbf{5}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        \\ \cline{3-7} 
\textbf{}  & \multicolumn{1}{c|}{\textbf{5}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{000000} \textbf{}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{000000} \textbf{}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{000000} \textbf{}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{000000} \textbf{}}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}{\color[HTML]{000000} \textbf{}}} \\ \cline{3-7} 
\textbf{}  & \multicolumn{1}{c|}{\textbf{3}} & \multicolumn{1}{c|}{\textbf{}}                                                & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\textbf{}}                                                \\ \cline{3-7} 
\textbf{}  & \multicolumn{1}{c|}{\textbf{1}} & \multicolumn{1}{c|}{\textbf{}}                                                & \multicolumn{1}{c|}{\textbf{}}                                                & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}\textbf{}}                        & \multicolumn{1}{c|}{\textbf{}}                                                & \multicolumn{1}{c|}{\textbf{}}   
                                             \\ \cline{3-7} 
\end{tabular}
\caption{Un exemple de Picross et sa solution.}
\end{table}
Certaines grilles peuvent ne pas avoir de solution, d'autres en avoir plusieurs.
\begin{table}[h]
\centering
\begin{tabular}{ccccc}
\textbf{}                       & \textbf{2}                                    & \textbf{2}                                    & \textbf{2}                                    & \textbf{2}                                    \\ \cline{2-5} 
\multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} \\ \cline{2-5} 
\multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} \\ \cline{2-5} 
\multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         \\ \cline{2-5} 
\multicolumn{1}{l|}{\textbf{2}} & \multicolumn{1}{l|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{l|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{l|}{}                         & \multicolumn{1}{l|}{}                         \\ \cline{2-5} 
\end{tabular}
\end{table}
\begin{table}[h]
\centering
\begin{tabular}{ccccc}
\textbf{}                       & \textbf{2}                                    & \textbf{2}                                    & \textbf{2}                                    & \textbf{2}                                    \\ \cline{2-5} 
\multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         \\ \cline{2-5} 
\multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         \\ \cline{2-5} 
\multicolumn{1}{c|}{\textbf{2}} & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} \\ \cline{2-5} 
\multicolumn{1}{l|}{\textbf{2}} & \multicolumn{1}{l|}{}                         & \multicolumn{1}{l|}{}                         & \multicolumn{1}{l|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{l|}{\cellcolor[HTML]{000000}} \\ \cline{2-5} 
\end{tabular}
\caption{Un exemple de Picross qui a deux solutions.}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{cccccc}
                   &                                 & \textbf{1}            & \textbf{}             & \textbf{}             & \textbf{1}            \\
                   & \textbf{}                       & \textbf{1}            & \textbf{1}            & \textbf{1}            & \textbf{1}            \\ \cline{3-6} 
\textbf{1}         & \multicolumn{1}{c|}{\textbf{1}} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \cline{3-6} 
\textit{\textbf{}} & \multicolumn{1}{c|}{\textbf{3}} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \cline{3-6} 
\textbf{1}         & \multicolumn{1}{c|}{\textbf{1}} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} \\ \cline{3-6} 
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{cccccc}
                   &                                 & \textbf{1}                                                           & \textbf{}                                     & \textbf{}                                     & \textbf{1}                                                           \\
                   & \textbf{}                       & \textbf{1}                                                           & \textbf{1}                                    & \textbf{1}                                    & \textbf{1}                                                           \\ \cline{3-6} 
\textbf{1}         & \multicolumn{1}{c|}{\textbf{1}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}}                        & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}}                        \\ \cline{3-6} 
\textit{\textbf{}} & \multicolumn{1}{c|}{\textbf{3}} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}{\color[HTML]{9B9B9B} }} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}{\color[HTML]{9B9B9B} }} \\ \cline{3-6} 
\textbf{1}         & \multicolumn{1}{c|}{\textbf{1}} & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}}                        & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{}                         & \multicolumn{1}{c|}{\cellcolor[HTML]{000000}}                        \\ \cline{3-6} 
\end{tabular}
\caption{Un exemple de Picross qui n'a pas de solution.}
\end{table}
\newpage

Le but du projet est d'implémenter un solveur de Picross en C++ qui, étant donnée une matrice et des indices liés à ses lignes/colonnes, calcule, puis affiche la solution. On ne considère que des Picross qui ont (au moins) une solution.\newline
La résolution d'une grille de Picross est un problème NP-complet (en temps Non-déterministe Polynomial). Pour le problème du Picross cela signifie qu'il ne faut pas espérer un algorithme qui résout n'importe quelle grille de Picross avec une complexité polynomiale, trouver une solution peut être très coûteux.
\section{Description de la méthode de résolution utilisée}
Afin de résoudre une grille de Picross donnée, nous traitons ses lignes indépendamment de ses colonnes.
Le traitement des lignes et des colonnes se faisant de la même manière; nous n'évoquerons par la suite que le traitement des lignes.
\newline
Une première méthode de résolution consisterait à générer toutes les solutions d'une ligne, partiellement remplie ou non; et de déterminer les cases noires ou blanches communes à chacune des solutions.
Une telle méthode permettrait de déterminer un plus grand nombre de cases. En revanche, elle serait très coûteuse.
\newline
C'est pourquoi, au lieu de générer toutes les solutions, nous avons choisi d'en générer deux; la plus à gauche et la plus à droite. Cette méthode ne permet pas de déterminer autant de cases que la précédente mais est nettement moins coûteuse.
\subsection{Résolution d'une ligne}
La résolution d'une ligne passe par l'appel de deux méthodes donnant respectivement la solution la plus à gauche et la solution la plus à droite de la ligne.
\newline
On fait ensuite la fusion de ces deux solutions afin de déterminer les cases nécessairement noires ou blanches.
\subsubsection{La méthode SLG}
La méthode SLG a pour but de générer la solution la plus à gauche d'une ligne contenant ou non des cases déjà déterminées.
Une fois un bloc placé, elle cherchera à placer le suivant, ainsi que tous les blocs de la liste d'indices de la ligne.
Afin d'expliciter son fonctionnement, son algorithme est explicité en page 9.
\subsubsection{Les méthodes SLPG et SLPD}
Les méthodes SLPG et SLPD sont les méthodes qui génèrent les deux solutions nécessaires à la résolution d'une ligne. Elles font toutes deux appel à SLG. 
\newline
Pour la solution la plus à droite, SLG est appelé sur une ligne et une liste d'indices préalablement inversés.
\subsubsection{La méthode Fusion}
Les appels à SLPG et SLPD nous donnent deux solutions possibles pour une ligne et, pour parvenir à sa résolution, il nous faut déterminer les cases n'ayant qu'une solution possible. 
\newline
Pour ce faire, on fait appel à Fusion qui placera les cases nécessairement noires.
Cette dernière nécessite que nos blocs de cases noires soient numérotés, on fait donc un appel préalable à une méthode Numeroter sur nos solutions SLPG-SLPD.
\newline
Fusion sera ainsi en mesure de noircir les cases qui sont noires dans SLPG et SLPD et qui ont le même numéro de bloc.
En effet, le statut de case noire sûre ne peut être défini que si une case noire commune aux deux solutions appartient à un même et unique bloc.
\newline
L'exemple ci-dessous illustre l'importance de cette spécification.  
\newline
\includegraphics[height=6.5cm,width=12cm]{Exemple1}
\subsubsection{La méthode remplirCasesSureBl}
Cette méthode est appelée après Fusion dans le but de placer les cases blanches sûres. Elle est en mesure de les déterminer grâce aux solutions SLPG-SLPD en calculant les envergures des blocs de cases noires. Dès lors, les espaces situés entre les intervalles trouvés sont des cases blanches sûres.\newline
Elle commence par générer une ligne de cases blanche de la même taille que celles prises en paramètres; à savoir, le résultat de Fusion et les solutions SLPG-SLPD; puis ``noircit'' les cases correspondantes à l'intervalle qu'occupe chacun des blocs dans l'une et l'autre des solutions SLPG-SLPD.
\newline
A la fin de ce procédé, elle copie les cases blanches restantes dans le résultat de Fusion.
\subsection{Résolution du Picross}
Pour résoudre un Picross, un appel initial des méthodes précédentes sur toutes les lignes et colonnes est effectué (cf. TINY\_SOL), cela à pour but d'initialiser nos listes d'indices de lignes/colonnes modifiées afin de rappeler les méthodes sur les lignes/colonnes correspondantes, et ce tant que les listes contiennent des cases modifiées (cf. FAT\_SOL).
\subsubsection{la méthode de Backtracking}
A l'aide de nos méthodes précédentes, il peut arriver que des cases ne puissent être déterminées;\newline
Nous avons choisi d'implémenter une méthode de backtracking 'simple' qui place une case indéterminée (arbitrairement, la première qu'il trouve en parcourant les lignes de la matrice) à noire et étudie les conséquences de cette coloration;
L'algorithme est explicité en annexe.
\newpage
\section{Description de l'implémentation}
\subsection{Les besoins du programme :}
\subsubsection{Pour les indices de chaque ligne/colonne:}
\begin{itemize}
\item Imperatif à satisfaire:
\begin{itemize}
\item structure de taille dynamique (nombre variable d'indices par lignes)
\item parcours en $\theta$(n) (plusieurs méthodes recourant à un parcours total ou partiel de la structure)
\item relation d'ordre (le parcours ne sont réalisés que dans l'ordre de l'indice le plus en haut vers celui le plus en bas respectivement gauche-droite pour les lignes)
\end{itemize}
\item Choix : la liste simplement chaînée, car elle correspond parfaitement aux spécifications.
\end{itemize}
\subsubsection{Pour représenter la grille du Picross :}
\begin{itemize}
\item Imperatif à satisfaire:
\begin{itemize}
\item structure de taille fixe
\item accès en temps constant a chaque case
\item facilitée de copie de la structure ($\theta$(n))
\end{itemize}
\item Choix: La matrice (Un tableau de tableaux)
\end{itemize}
\subsubsection{Pour l'ensemble des indices de lignes/colonnes :}
\begin{itemize}
\item Imperatif à satisfaire:
\begin{itemize}
\item accès en temps constant a chaque liste
\item indicage cohérent avec la matrice
\end{itemize}
\item Choix : Un tableau de listes
\end{itemize}
\subsubsection{Pour ligmodif/colmodif}
\begin{itemize}
\item Imperatif à satisfaire:
\begin{itemize}
\item ajout d'un élément en temps constant
\item retrait d'un élément en temps constant
\item taille dynamique
\end{itemize}
\item Choix :
Le choix naturel serait l'ensemble mais nous avons choisi la liste simplement chaînée car déjà implémentée.
\end{itemize}
\subsection{Les classes}
\subsubsection{La classe Cell :}
\begin{itemize}
\item Attributs :
\begin{itemize}
\item Val : contient la valeur d'un bloc de case ou un indice
\item Suiv : pointeur sur la cellule suivante de la liste
\end{itemize}
\end{itemize}
\subsubsection{La classe Liste :}
\begin{itemize}
\item Attributs :
\begin{itemize}
\item Longueur : contient le nombres de cellules de la liste.
\item Fini : indique si la ligne/colonne à laquelle est rattachée la liste est entièrement rempli (booléen à true) ou non (booléen à false), cet attribut est
notamment très utile pour vérifier la condition d'arrêt de notre résolution.
\item Tête : Pointeur vers le premier élément de la liste.
\end{itemize}
\item Méthode remarquable :
\begin{itemize}
\item Surcharge de l'opérateur() : Nous l'utilisons notamment pour faciliter l'accès à un élément de la liste.
\end{itemize}
\end{itemize}
\subsubsection{La classe Tabliste :}
\begin{itemize}
\item Attributs :
\begin{itemize}
\item Tab : le tableau de listes
\item Taille : la taille du tableau
\end{itemize}
\item Méthode remarquable :
\begin{itemize}
\item Surcharge de l'opérateur[]: Nous permet l'accès aux listes en temps constant comme pour un tableau.
\end{itemize}
\end{itemize}
\subsubsection{La classe Matrice :}
\begin{itemize}
\item Attributs:
\begin{itemize}
\item Mat : la matrice d'entiers
\item Nbl : Nombre de ligne
\item Nbc : Nombre de colonnes
\end{itemize}
\end{itemize}
\subsubsection{La classe Picross :}
La classe Picross est la classe dont l'instance représente le Picross; S'est dans cette classe que sont implémentées nos méthodes de résolution.
\begin{itemize}
\item Attributs:
\begin{itemize}
\item Une Matrice (-1 : blanc, 0 : indéterminé, 1 : noir)
\item Deux TabListes pour nos listes de blocs
\item Deux listes d'indices ligModif et colModif pour limiter nos récursions
\end{itemize}
\end{itemize}
\newpage
\subsection{Algorithme remarquable :}
\subsubsection{SLG :}
\paragraph{Spécification :}
 void SLG(int*, short int, Cell*, short int, bool\&);
\begin{itemize}
\item Paramètres:
\begin{itemize}
\item Un tableau d'entier: (Donnée/résultat) il représente une ligne/colonne de notre matrice, initialement il peut contenir des cellules à 1,-1,0
\item Un short int : représentant la taille du tableau
\item Une cellule de liste: il représente le prochain indice a placer dans le tableau, initialement la première cellule associé à la dite ligne/colonne
\item Un short int : représentant l'indice dans le tableau auquel on souhaite placer le bloc, initialement 0
\item Un booléen passé par référence : représentant si il est possible ou non de placer la fin de la liste d'indices indice courant compté a partir de l'indice courant dans le tableau.
\end{itemize}
\item Retour de la fonction.
\end{itemize}
Le retour ce fait par l'intermédiaire du tableau et du booléen. Si le booléen est à false c'est que le couple (ligne/colonne,liste d'indice) n'a pas de solution. Dans le cas contraire, la solution la plus à gauche nous est donnée dans le tableau.
\paragraph{SLG}(L: ligne; n: taille de la ligne; Lind: liste d'indices; i: entier; possible: booleen)
\begin{description}
\item[Debut]
\item[]
  \begin{itemize}
  \item[Si] Lind est vide alors 
    \begin{itemize}
    \item Si L ne contient pas de cases noires après l'indice i alors
      \begin{itemize}
      \item on blanchit toutes les cases de L d'indices supérieurs à i;
      \end{itemize}
    \item Sinon 
      \begin{itemize}
      \item possible == faux;
      \end{itemize}
    \end{itemize}
  \item[Sinon] on essaie de placer le 1er bloc de Lind à l'indice i
    \begin{itemize}
    \item Si on y arrive pas alors
      \begin{itemize}
      \item si L[i] n'est pas noir alors 
        \begin{itemize}
        \item SLG(L, n, Lind, i+1, possible);
        \end{itemize}
      \item sinon 
        \begin{itemize}
        \item possible == faux;
        \end{itemize}
      \end{itemize}
    \item Sinon
      \begin{itemize}
      \item SLG(L, n, queue(L), i+tête(L)+1, possible);
      \end{itemize}
    \end{itemize}
  \item[Si] non possible alors 
    \begin{itemize}
    \item Si L[i] n'est pas noir alors
      \begin{itemize}
      \item SLG(L, n, Lind, i+1, possible);
      \end{itemize}
    \item Sinon 
      \begin{itemize}
      \item possible == faux;
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item[Fin algorithme]
\end{description}
\newpage
\paragraph{Complexité pire des cas : $\theta(n^2) <$c$\leq\theta(2^n)$\\ }
 Notons :
\begin{itemize}
\item i: l'indice dans notre tableau
\item n: la taille du dit tableau
\item T: le dit tableau
\item l: la taille de la liste d'indice (le nombre d'indices)
\item $m_i$: l'envergure d'un indice i
\end{itemize}
Dans le pire des cas de notre algorithme, on peut imaginer que chaque hypothèse faite par notre algorithme soit fausse. Pour cela, il nous faut imaginer une liste d'indice de petite taille (ici on choisira $\forall$i $\in$[0,l[ $m_i$=1). En effet, plus les indices sont grands moins ils ont de positions possibles pour une même taille de tableau, et donc moins d'hypothèses.
\newline Enfin, on voit bien que la complexité va dépendre de la taille de la liste; en effet, chaque cellule appelle la fonction au moins une fois pour chaque maillons placé après dans liste. Au plus, pour un indice j de la liste SLG sera appelée $\sum_{i=l-j}^{l} (i)$ fois c'est à dire l-i fois $\forall$i $\in$[j,l[.
\newline En outre, on sait que le coût de SLG sans les appels récursifs revient à n puisque dans tous les cas où la liste n'est pas vide, on recopie le tableau. Sinon, si la liste est vide, on parcours le tableau de l'indice i à n. Ici, on considérera cette valeur cst=n, bien que ce cas soit défavorable. Il n'est pas réaliste en effet, dans le cas d'une liste non-vide (ce qui est notre cas) cette valeur est nécessairement inférieure et décroit tout au long des appels de SLG.
Soit une complexité inférieure à $2^n$.
\newline
Avec ce modèle défavorable on obtient l'équation de récursion suivante:
\begin{center}
 \fbox{SLG(i)= $\sum_{k=l-i}^{l} (SLG(k)*n)+cst$}
\end{center}
Ainsi, en notant c la complexité dans ce pire des cas: $\theta(n^2) <$c$\leq\theta(2^n)$; pour chaque case on parcours au minimum une fois le tableau (la recopie) pour chaque cellule après ici cela fait déjà $\theta(n^2)$ et on doit le faire pour chaque indice.
\subsection{L'interface graphique:}
Pour implémenter une interface utilisateur graphique et afficher notre Picross on utilise la bibliothèque Gtkmm, qui est une surcouche de GTK pour le langage C++.
Dans une fenêtre du programme on a quatre boutons:
\begin{itemize}
\item  ``Description'' contient une brève description du programme;
\item ``Ouvrir'' pour ouvrir un fichier texte (nos grilles Picross), qui permet l'initialisation d'une grille vide avec ses indices;
\item ``Résolution'' permet le déclenchement de nos méthodes de résolution et affiche la grille ainsi résolue;
\item ``Quitter'' appel d'une fonction GTK permettant la fermeture de la fenêtre.
\end{itemize}
\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=15cm]{picross}
\end{center}
\caption{Un exemple de solution Picross.}
\end{figure}
\end{landscape}
\section{Ameliorations/Evolution du programme:}
\begin{itemize}
\item Dans le cas où le picross nécessite un backtrack pour sa résolution, les cases restantes peuvent se voir attribuer un degré de liberté, et la case ainsi déterminée la plus probable aurait alors été celle choisi pour lancer le backtracking.
\item Dans le souci d'améliorer la complexité de la résolution d'une grille en moyenne, nous aurions pû, plutôt que de faire des copies/recopies de matrices entre les environnements de backtrack, ne maintenir que les cases modifiées entre les environnements de backtracks;
Cela dit, dans le pire des cas (1ere hypothese fausse), la complexité reste équivalente ($\theta(n^2)$) car l'ensemble des cases se verraient modifiées après le premier environnement de backtrack. (Exemple BT 1 sol)
\item L'implémentation de méthodes permettant de rentrer des grilles de Picross graphiquement (au clic).
\item L'implémentation de méthodes permettant de résoudre des grilles de Picross graphiquement (au clic).
\item Dans certains cas la méthode pour trouver les cases blanches sûres que nous avons choisies ne trouve pas toutes les cases blanches que nous aurions pu déterminer. Par exemple :
\begin{center}
\includegraphics[width=11cm]{image1}
\end{center}
En effet, il n’y a aucun chevauchement de noir appartenant au même bloc, et aucun blanc qui ne soit dans l’envergure des blocs. Pourtant on peut aisément voir que la case d’indice 4 (indice débutant à 0) est blanche puisqu’elle est coincée entre deux blanches et que la taille minimum des blocs est de deux. On pourrait donc imaginer un algorithme qui teste pour chaque blocs d’indéterminés coincés entre deux blancs si sa taille est inférieure au plus petit indice à rentrer,  dans ce cas on le blanchit.
\end{itemize}
\section{Annexes :}
\subsection{Algorithme de backtracking :}
\begin{verbatim}
void Picross::backtrack(bool &poss)
{
  FAT_SOL(ligModif.getLongueur()); //méthode de résolution
  if(!isPicrossFini())
  {
    int** SAVE=copieMat();	//Copie de la matrice
    bool* TL=new bool [getNbLignes()];
    bool* TC=new bool [getNbColonnes()];
    copieBool(TL,TC);	//Copie de nos booléens lignes|colonnes finies
    sint i=0,j=0;	//Indices utilisés pour le placement de la case noire
    Placer1noir(poss,i,j);	//poss à true ssi la matrice contient un indéterminé(0) 
                               //on place un noir(1) et on initialise (i,j)
    if(poss)
    {
      backtrack(poss);	//On recommence
//A ce niveau nous sommes dans le dernier environnement où on à Placer1noir(i,j)
//Si le picross n'est pas correctement rempli qu'on à pas pu Placer1noir poss=false
      if(!poss)
      {
        recopieMat(SAVE);	//Recopie de la matrice sauvegardée avant le placement du noir
        recopieBool(TL,TC);	//Recopie de nos booléens fini qui auraient pu être modifiés
        Placer1blanc(i,j);	//On place la case (i,j) à blanc
        backtrack(poss);	//On recommence
      }
    }
  }
}
\end{verbatim}
\subsection{Schéma de l'implémentation :}
\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=15cm]{./images/recapitulatif_stucture.png}
\end{center}
\end{figure}
\end{landscape}
\newpage
\subsection{Construire une grille de Picross :}
\begin{figure}[h]
\begin{center}
\includegraphics[width=8cm]{ex2}
\end{center}
\caption{Un exemple de fichier.}
\end{figure}
\end{document}
